package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	var dir string
	flag.StringVar(&dir, "dir", "./../../internal", "path to scan")
	flag.Parse()

	err := filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() {
			return nil
		}

		if strings.HasPrefix(d.Name(), ".") {
			return filepath.SkipDir
		}

		fileSet := token.NewFileSet()
		pkgs, err := parser.ParseDir(fileSet, path, nil, parser.ParseComments)
		if err != nil {
			return fmt.Errorf("could not parse dir %s: %w", dir, err)
		}

		for _, pkg := range pkgs {
			var resetMethods []string

			for _, file := range pkg.Files {
				for _, decl := range file.Decls {
					gen, ok := decl.(*ast.GenDecl)
					if !ok || gen.Tok != token.TYPE || gen.Doc == nil || len(gen.Doc.List) == 0 {
						continue
					}

					if !hasGenResetComment(gen.Doc.List) {
						continue
					}

					for _, spec := range gen.Specs {
						typeSpec, ok := spec.(*ast.TypeSpec)
						if !ok {
							continue
						}

						structType, ok := typeSpec.Type.(*ast.StructType)
						if !ok {
							continue
						}

						methodCode := makeResetMethod(typeSpec.Name.Name, structType, fileSet)
						resetMethods = append(resetMethods, methodCode)
					}
				}
			}

			if len(resetMethods) == 0 {
				continue
			}

			content := fmt.Sprintf("// Code generated by reset tool. DO NOT EDIT.\n\npackage %s\n\n%s", pkg.Name, strings.Join(resetMethods, "\n\n"))

			filename := filepath.Join(path, "reset.gen.go")
			err := os.WriteFile(filename, []byte(content), 0644)
			if err != nil {
				return fmt.Errorf("could not write file %s: %w", filename, err)
			}
			fmt.Printf("generated: %s\n", filename)
		}

		return nil
	})
	if err != nil {
		fmt.Fprintf(os.Stderr, "error scanning dir: %v\n", err)
		os.Exit(1)
	}
}

func hasGenResetComment(list []*ast.Comment) bool {
	for _, comment := range list {
		if strings.Contains(comment.Text, "generate:reset") {
			return true
		}
	}
	return false
}

func makeResetMethod(typeName string, structType *ast.StructType, fset *token.FileSet) string {
	var lines []string
	lines = append(lines, fmt.Sprintf("func (rs *%s) Reset() {", typeName))
	lines = append(lines, "\tif rs == nil {")
	lines = append(lines, "\t\treturn")
	lines = append(lines, "\t}")

	for _, field := range structType.Fields.List {
		name := field.Names[0].Name

		line := ""
		switch t := field.Type.(type) {
		case *ast.MapType:
			line = "clear(rs." + name + ")"
		case *ast.ArrayType:
			line = "rs." + name + " = rs." + name + "[:0]"
		case *ast.Ident: // primitives
			switch t.Name {
			case "string":
				line = `rs.` + name + ` = ""`
			case "bool":
				line = "rs." + name + " = false"
			default:
				line = "rs." + name + " = 0"
			}
		case *ast.StructType:
			line = "rs." + name + " = " + "{}"
		case *ast.InterfaceType, *ast.FuncType, *ast.ChanType, *ast.StarExpr:
			line = "rs." + name + " = nil"
		case *ast.SelectorExpr: // mutex no need to reset
		default:
			line = "rs." + name + " = nil2"
		}
		lines = append(lines, "\t"+line)
	}

	lines = append(lines, "}")
	return strings.Join(lines, "\n")
}
