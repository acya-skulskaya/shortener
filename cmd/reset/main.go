package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const fileTemplate = `// Code generated by reset tool. DO NOT EDIT.
    
package {{.Name}}
    
{{range .Structs}}
func (rs *{{.Name}}) Reset() {
    if rs == nil {
        return
    }
	{{- range .Fields}}
    {{ . }}
    {{- end}}
}
{{end}}
`

type resetPackage struct {
	Name    string
	Structs []resetStruct
}

type resetStruct struct {
	Name   string
	Fields []string
}

var tpl = template.Must(template.New("reset").Parse(fileTemplate))

func main() {
	var dir string
	flag.StringVar(&dir, "dir", "./../../internal", "path to scan")
	flag.Parse()

	err := filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() {
			return nil
		}

		if strings.HasPrefix(d.Name(), ".") {
			return filepath.SkipDir
		}

		fileSet := token.NewFileSet()
		pkgs, err := parser.ParseDir(fileSet, path, nil, parser.ParseComments)
		if err != nil {
			return fmt.Errorf("could not parse dir %s: %w", dir, err)
		}

		for _, pkg := range pkgs {
			var resetStructs []resetStruct

			for _, file := range pkg.Files {
				for _, decl := range file.Decls {
					gen, ok := decl.(*ast.GenDecl)
					if !ok || gen.Tok != token.TYPE || gen.Doc == nil || len(gen.Doc.List) == 0 {
						continue
					}

					if !hasGenResetComment(gen.Doc.List) {
						continue
					}

					for _, spec := range gen.Specs {
						typeSpec, ok := spec.(*ast.TypeSpec)
						if !ok {
							continue
						}

						structType, ok := typeSpec.Type.(*ast.StructType)
						if !ok {
							continue
						}

						rs := makeResetMethod(typeSpec.Name.Name, structType, fileSet)
						resetStructs = append(resetStructs, rs)
					}
				}
			}

			if len(resetStructs) == 0 {
				continue
			}

			rp := resetPackage{
				Name:    pkg.Name,
				Structs: resetStructs,
			}

			filename := filepath.Join(path, "reset.gen.go")

			err = saveResetMethodsFile(filename, rp)
			if err != nil {
				fmt.Fprintf(os.Stderr, "could not save reset methods file %s: %v", filename, err)
				continue
			}

			fmt.Printf("generated: %s\n", filename)
		}

		return nil
	})
	if err != nil {
		fmt.Fprintf(os.Stderr, "error scanning dir: %v\n", err)
		os.Exit(1)
	}
}

func saveResetMethodsFile(filename string, rp resetPackage) error {
	f, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("could not create file %s: %w", filename, err)
	}
	defer f.Close()

	err = tpl.Execute(f, rp)
	if err != nil {
		return fmt.Errorf("could not apply file template %s: %w", filename, err)
	}

	return nil
}

func hasGenResetComment(list []*ast.Comment) bool {
	for _, comment := range list {
		if strings.Contains(comment.Text, "generate:reset") {
			return true
		}
	}
	return false
}

func makeResetMethod(typeName string, structType *ast.StructType, fset *token.FileSet) resetStruct {
	rs := resetStruct{
		Name:   typeName,
		Fields: make([]string, len(structType.Fields.List)),
	}

	for _, field := range structType.Fields.List {
		name := field.Names[0].Name

		line := ""
		switch t := field.Type.(type) {
		case *ast.MapType:
			line = "clear(rs." + name + ")"
		case *ast.ArrayType:
			line = "rs." + name + " = rs." + name + "[:0]"
		case *ast.Ident: // primitives
			switch t.Name {
			case "string":
				line = `rs.` + name + ` = ""`
			case "bool":
				line = "rs." + name + " = false"
			default:
				line = "rs." + name + " = 0"
			}
		case *ast.StructType:
			line = "rs." + name + " = " + "{}"
		case *ast.InterfaceType, *ast.FuncType, *ast.ChanType, *ast.StarExpr:
			line = "rs." + name + " = nil"
		case *ast.SelectorExpr: // mutex no need to reset
		default:
			line = "rs." + name + " = nil"
		}
		rs.Fields = append(rs.Fields, line)
	}

	return rs
}
